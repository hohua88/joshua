<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>iOS手势密码实现机制</title>
    <style type="text/css" media="all">
      body {
        margin: 0;
        font-family: "Helvetica Neue", Helvetica, Arial, "Hiragino Sans GB", sans-serif;
        font-size: 14px;
        line-height: 20px;
        color: #777;
        background-color: white;
      }
      .container {
        width: 700px;
        margin-right: auto;
        margin-left: auto;
      }

      .post {
        font-family: Georgia, "Times New Roman", Times, "SimSun", serif;
        position: relative;
        padding: 70px;
        bottom: 0;
        overflow-y: auto;
        font-size: 16px;
        font-weight: normal;
        line-height: 25px;
        color: #515151;
      }

      .post h1{
        font-size: 50px;
        font-weight: 500;
        line-height: 60px;
        margin-bottom: 40px;
        color: inherit;
      }

      .post p {
        margin: 0 0 35px 0;
      }

      .post img {
        border: 1px solid #D9D9D9;
      }

      .post a {
        color: #28A1C5;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <div class="post">
        <h1 class="title">iOS手势密码实现机制</h1>
        <div class="show-content">
          <p>基于手势密码的安全性与交互性比较好，一直以来都是手机APP的标配。在接手公司项目的时候，项目已经实现了手势密码。但是集成在项目中的手势密码功能一直没有达到老大要求和手Q一致的需求。在研究了手Q的弹出机制之后，我发现主要的差距是在app进入后台再次点击图标进入程序：手势密码界面会滞后？（即手势密码弹出是在主界面出现之后再弹出）</p><p>我查看了代码实现是写一个基础ViewController，在viewDidAppear监听手势密码监听事件，代码示例如下：</p><blockquote><p>[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(verifyGesturePwd) name:@"VerifyGesturePwd" object:nil];</p></blockquote><p>我们姑且不论代码的书写，此代码在不继承这个基础view controller的情况下，手势密码是弹不出的。并且实现不了直接弹出手势密码的要求。</p><p>中间我尝试在这个基础上做修改，即把监听代码放到viewWillAppear中，结果你肯定也猜到了，没有用，因为这还是在界面生成之后弹出的。那怎么解决这个需求呢？我陷入了这个死胡同。难道这个问题就解决不了了吗？答案肯定是可以解决，因为人家已经实现了这个功能。</p><p>最近刚好看到订阅专栏里面一篇关于“万能钥匙”的文章，文章的主题就是不要盯着锁头找钥匙，要到其他地方找钥匙。很显然我就是陷入了盯着问题找答案的死胡同，此时我豁然开朗。找到解题的关键：答案在别处。我应该在程序入口的地方来完成项目需求。下面给出我的实现。</p><p>1、在每次程序启动时，在didFinishLaunchingWithOptions方法中判断是否设置手势密码，如果有手势密码功能的话，直接把手势密码界面设置为rootViewController，没有的话就判断是否登录账号，登录就设置MainViewController为rootViewController，否则就设置登录界面为rootViewController。并注册一个登录的监听。</p><blockquote>
<p>if ([DBUtil objectForKey:kDB_GestureValid]) {</p>
<p>VertifyGesViewController *controller = [VertifyGesViewController new];</p>
<p>UINavigationController *nav = [[UINavigationController alloc] initWithRootViewController:controller];</p>
<p>self.window.rootViewController = nav;</p>
<p>}</p>
<p>else{</p>
<p>[self loginStateChange:nil];</p>
<p>[[NSNotificationCenter defaultCenter] addObserver:self</p>
<p>selector:@selector(loginStateChange:)</p>
<p>name:KNOTIFICATION_LOGINCHANGE</p>
<p>object:nil];</p>
</blockquote><p>其中loginStateChange的处理逻辑如下：</p><blockquote>
<p>- (void)loginStateChange:(NSNotification *)notification{</p>
<p>if (notification == nil) {</p>
<p>[self userLogined];</p>
<p>}else{</p>
<p>BOOL loginSuccess = [notification.object boolValue];</p>
<p>if (loginSuccess) {</p>
<p>[self userLogined];</p>
<p>}</p>
<p>else{</p>
<p>[self userLoginOut];</p>
<p>}</p>
<p>}</p>
<p>}</p>
</blockquote><blockquote>
<p>- (void)userLogined{</p>
<p>self.window.rootViewController = [MainViewController new];</p>
<p>}</p>
</blockquote><blockquote>
<p>- (void)userLoginOut{</p>
<p>self.window.rootViewController = [[UINavigationController alloc]initWithRootViewController:[LoginViewController new]];</p>
<p>}</p>
</blockquote><p>2、 为了处理方便，我在手势密码验证后把逻辑放到登录状态监听里面。即在验证后判断如果当前手势界面是设置的rootViewController时，发出通知。监听处需要重新设置rootViewController。</p><blockquote>
<p>if (self.navigationController) {</p>
<p>[[NSNotificationCenter defaultCenter] postNotificationName:KNOTIFICATION_LOGINCHANGE object:@YES];</p>
<p>}else{</p>
<p>[self dismissViewControllerAnimated:YES completion:^{}];</p>
<p>}</p>
</blockquote><p>3、在程序进入后台时，如果手势密码已设置，弹出手势密码即可。</p><blockquote>
<p>if ([DBUtil boolForKey:kDB_GestureValid]) { //手势密码有效</p>
<p>[self.window.rootViewController presentViewController:[VertifyGesViewController new] animated:NO completion:nil];</p>
<p>}</p>
</blockquote><p>4、在测试的时候发现有个小bug，即在杀死程序再次进入应用时，直接进入后台发现手势密码界面有2个。此处只需要添加如下代码逻辑来解决重复弹出的问题。</p><blockquote>
<p>UIViewController *rootViewController = [[[UIApplication sharedApplication] delegate] window].rootViewController;</p>
<p>if ([rootViewController isKindOfClass:[UINavigationController class]]) {</p>
<p>return;</p>
<p>}</p>
</blockquote><p>行文至此，这个功能需求被实现了出来。说一下自己的一点小感悟：1、很多你觉得不可能完成的任务，其实是你还没有找到解决方法。2、不要盯着锁头找钥匙，钥匙一定在其他地方。</p><p>今天抽时间把手势密码抽离出来，<a href="https://github.com/hohua88/Gesture" target="_blank">https://github.com/hohua88/Gesture</a>，欢迎交流。</p><p>#未完再续</p><p>上述实现在当前页面有Alert或者键盘时，弹出的验证手势密码界面会出现遮挡(既Alert或者键盘)。这是由于Alert／键盘是展示在UIWindow上的，会显示在手势密码界面的上面。</p><p>有兴趣的可以去<a href="https://developer.apple.com/library/content/documentation/WindowsViews/Conceptual/ViewPG_iPhoneOS/CreatingWindows/CreatingWindows.html#//apple_ref/doc/uid/TP40009503-CH4-SW1" target="_blank">Window官方文档</a>，这里就不展开描述了。这里为了解决遮挡问题，可以通过设置UIWindowLevel为UIWindowLevelAlert来做到手势密码显示在最上层。</p><blockquote>
<p>- (void)show {</p>
<p>            self.windowLevel = UIWindowLevelAlert;</p>
<p>            [self makeKeyWindow];</p>
<p>            self.hidden = NO;</p>
<p>}</p>
</blockquote><p>这样做的话，想要再弹出Alert提示框就需要自己自定义添加到window上。想尝试的可以自己实现一下。</p><p>参考链接：<a href="https://www.cnblogs.com/junhuawang/p/6004918.html" target="_blank">UIWindow 详解及使用场景</a></p>
        </div>
      </div>
    </div>
  </body>
</html>
